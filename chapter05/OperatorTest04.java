/*
    赋值运算符：
        1、赋值运算符包括"基本赋值运算符"和"扩展赋值运算符"：基本的、扩展的。
        2、基本赋值运算符？
            =
        3、扩展的赋值运算符？
            +=
            -=
            *=
            /=
            %=
           注意：扩展赋值运算符在编写的时候，两个符号之间不能有空格。
        4、很重要的语法机制:
            使用扩展赋值运算符的时候，永远都不会改变运算结果类型。
            byte x = 100;
            x += 1;
            x 自诞生以来是byte类型，那么x变量的类型永远都是byte。不会变。不管后面是多大的数字。

 */
public class OperatorTest04{
    public static void main(String[] args){

        //赋值运算符"="右边优先级比较高，先执行右边的表达式
        //然后将表达式执行结束的结果放到左边的"盒子"当中。（赋值）
        int i =10;
        i = 20;//重新赋值
/*
    以 += 运算符作为代表，学习扩展赋值运算符。
    其他的运算符，例如：-= *= /= %= 和 += 原理相似
 */
        int k = 10;
        k += 20;//k变量追加20
        System.out.println(k);//30

        int m = 10;
        // += 运算符类似于下面的表达式
        m = m+20;
        System.out.println(m);//30

        //研究：
        //i += 10 和i = i+10 真的是完全一样吗？
        //答案：不一样，只能说是相似，其实本质上并不是完全相同。
        byte x = 100;// 100没有超出byte的取值范围，可以直接赋值
        System.out.println(x);

        //x = x+1;
        //错误：不兼容的类型：从int转换到byte可能会有损失
        //编译器检测到 x+1 是int类型，int类型不可以直接赋值给byte类型，需要加强制转换符。

        //使用扩展运算符可以吗？
        //可以的，所以得出结论：x +=1 和x = x+1 不一样。
        //其实 x +=1; 等同于： x = （byte）（x+1）;
        x += 1 ;
        System.out.println(x);//101
        x += 199;// x = (byte) (x+199);
        //超出byte的取值范围，自动损失精度
        System.out.println(x);//44

        long h = 300;
        h *= 10;
        System.out.println(h);//3000
        h /= 30;
        System.out.println(h);//100
        h %= 7;
        System.out.println(h);//2
        h -= 1;
        System.out.println(h);//1
    }
}